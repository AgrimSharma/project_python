# ScrumDo - Agile/Scrum story management web application
# Copyright (C) 2010 - 2016 ScrumDo LLC
#
# This software is not licensed for redistribution in any form.

from apps.extras.interfaces import ScrumdoProjectExtra
from django.template import RequestContext
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.core.urlresolvers import reverse
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

import urllib2
import datetime
import logging
import sys, traceback

from apps.extras.models import StoryQueue, SyncronizationQueue, ExternalStoryMapping, ExternalTaskMapping
from apps.projects.models import Story, Task, Project
import forms
import re
import time
import apps.extras.signals as extras_signals

from jira import Jira
import configuration

logger = logging.getLogger(__name__)

class JiraExtra( ScrumdoProjectExtra ):
    """ This Extra allows you to work with Jira """

    def getName(self):
        "Friendly name to display in the configuration options to the user."
        return "Jira"

    def availableFor(self, project):
        # only scrum projects.
        return project.project_type == Project.PROJECT_TYPE_SCRUM


    def getLogo(self):
        return settings.SSL_STATIC_URL + "extras/jira_logo.png"

    def getSlug(self):
        "Returns a version of the name consisting of only letters, numbers, or dashes"
        return "jira"

    def getDescription(self):
        return "Track bugs about ScrumDo stories or create stories from Jira bugs.<br/><br/>Currently in <b>Beta</b>, please let us know of any issues."

    def doProjectConfiguration( self, request, project, stage=""):     
        if stage == "report":
            return self.doReportBug(request, project )       
        
        return configuration.doProjectConfiguration(self, request, project, stage)    

    def doReportBug(self, request, project ):
        try:
            config = self.getConfiguration( project.slug )    
            storyId = request.GET.get("story")
            story = project.stories.get(id=storyId)
            url = config[configuration.URL_FIELD]
            username = config[configuration.USERNAME_FIELD]
            password = config[configuration.PASSWORD_FIELD]
            jira = Jira(url, username, password)
            summary = "Autogenerated bug for Story %s-%d" % (project.prefix, story.local_id)
            desc = "Bug reported for [Story %s-%d|%s%s#story_%s]" % (project.prefix, story.local_id, settings.BASE_URL, reverse('iteration', args=[story.project.slug, story.iteration.id]), story.id )
            issue = jira.createIssue(config[configuration.PROJECT_FIELD], summary, desc)
            # logger.debug( issue )
        
            task = Task(story = story,
                        summary = "Fix bug %s" % issue.key )
            task.save()
        
            mapping = ExternalTaskMapping( task = task,
                                            external_id = issue.key,
                                            external_url = self._buildURL(config, issue.key),
                                            extra_slug = self.getSlug() )
            mapping.save()
        

            url = "%s/secure/EditIssue!default.jspa?id=%s" % (config[configuration.URL_FIELD], issue.id)
            return HttpResponseRedirect( url )
        except:
            # (?P<extra_slug>[-\w]*)/(?P<project_slug>[-\w]*)/configure
            return HttpResponseRedirect( reverse("configure_extra_url", kwargs={"extra_slug":self.getSlug(), "project_slug":project.slug} ) )

    def isPremium(self):
        return True

    def getExtraStoryActions(self, project, story):
        """ Should return a list of tupples with a label, url, silk icon, that represent actions that a user can manually
            invoke for this extra on a story. Example: ('Syncronize','/blah/blah/syncronize','') """
        
        if not self._isConfigured(project):            
            return []
            
        config = self.getConfiguration( project.slug )               
        if not config.get( configuration.CONFIGURED_FIELD ):
            return []
        return [("Report Bug",
                 "%s?story=%d" % (reverse("configure_extra_with_stage",kwargs={'stage':'report', 'project_slug':project.slug,'extra_slug':self.getSlug()}), story.id), 
                 'icon-warning-sign')]

    def getExtraActions( self, project, **kwargs):        
        if not self._isConfigured(project):            
            return []
        config = self.getConfiguration( project.slug )               
        bug_link = "%s/secure/CreateIssue!default.jspa" % config[configuration.URL_FIELD]
        return [("Synchronize",
                 "%s?syncronize=now" % reverse("configure_extra_url",kwargs={'project_slug':project.slug,'extra_slug':self.getSlug()}), 
                 'arrow_refresh'),
                 ("Log a bug", bug_link, 'icon-warning-sign')
                 ]    

    def storyDeleted( self, project, external_id, **kwargs):
        pass # not going to delete the Jira issue

    def storyCreated( self, project, story, **kwargs):
        pass # No automatic issue creation.
    
    
    def _updateStory(self, project, story, issue, config):
        """ Takes a Story or StoryQueue object and updates it's contents from an issue returned
            from the Jira API """
        story.summary = issue.summary
        story.detail = issue.description if issue.description else ""
        self._updateStoryStatus(story, issue.status, config)
        story.save()
    
    def _createStoryQueue(self, project, issue, config ):
        logger.debug("Creating story queue")
        q = StoryQueue( project=project, 
                        extra_slug=self.getSlug(), 
                        external_id=issue.key, 
                        external_url=self._buildURL(config, issue.key), 
                        summary=issue.summary, 
                        detail=issue.description if issue.description else "")
        self._updateStoryStatus(q, issue.status, config)
        q.save()
        
    
    def _buildURL( self, config, key ):
        # http://localhost:8080/browse/SCRUMDO-1
        return "%s/browse/%s" % (config[configuration.URL_FIELD],key)
      
    def _createStory(self, project, story, config):
        pass
        
    def associate( self, project):
        pass

    def unassociate( self, project):
        pass

    def getShortStatus(self, project):
        try:
            configuration = self.getConfiguration( project.slug )
            return configuration.get("status")
        except:
            return "Not configured"
        

    def pullProject( self, project ):
        
        
        if not self._isConfigured(project):            
            return
        config = None
        
        try:                       
            config, jira = self._getConfigJira(project)

            if not config[configuration.IMPORT_FIELD]:
                # We're not importing bugs as stories.
                return

            queue_stories = StoryQueue.objects.filter( project=project, extra_slug=self.getSlug() )
            project_stories = self._getStoriesInProjectAssociatedWithExtra( project )        
            
            filterID = config[configuration.FILTER_FIELD]
            bugCount = jira.getIssueCount( filterID )
            logger.debug("About to process %d bugs" % bugCount )
            offset = 0
            while True:
                issues = jira.getIssues(filterID, offset, 2)
                count = len(issues) 
                if count == 0:
                    break
                offset += count
                for issue in issues:
                    try:
                        externalID = issue.key
                        existing_story = self._getStory( externalID, queue_stories, project_stories )
                        existing_tasks = ExternalTaskMapping.objects.filter(task__story__project=project, external_id=issue.key)
                        if existing_story:
                            self._updateStory(project, existing_story, issue, config)
                        elif existing_tasks.count() == 0:
                            self._createStoryQueue( project, issue, config )
                    except:
                        logger.error("Could not sync issue %s" % issue.key)
                        traceback.print_exc(file=sys.stdout)

                        
            logger.debug("Processed %d bugs" % offset) 
            self.setStatus(project,config,"Synchronization successful on " + str( datetime.date.today()  ), False)            
        except:
            if config:
                self.setStatus(project,config,"Synchronization failed on " + str( datetime.date.today()  ), False)


    def _updateStoryStatus(self, story, statusID, config):        
        pass
        # For now, not trying to force jira issues to a status, the custom workflows
        # they can support are just too complex to deal with right now.
        #
        # if config[configuration.STATUS_TODO] == statusID:
        #     story.status = Story.STATUS_TODO
        # if config[configuration.STATUS_DOING] == statusID:
        #     story.status = Story.STATUS_DOING
        # if config[configuration.STATUS_REVIEWING] == statusID:
        #     story.status = Story.STATUS_REVIEWING
        # if config[configuration.STATUS_DOING] == statusID:
        #     story.status = Story.STATUS_DOING        
        
            
    def setStatus(self, project, config, status, in_progress):        
        config["status"] = status
        config["in_progress"] = in_progress
        self.saveConfiguration( project.slug, config )
        

    def initialSync( self, project):        
        self.pullProject( project )       

    def storyUpdated( self, project, story , **kwargs):        
        
        if not self._isConfigured(project):            
            return
        
        # A scrumdo story was updated
        config, jira = self._getConfigJira(project)
        
        if not config[configuration.IMPORT_FIELD]:
            # We're not importing bugs as stories.
            return
        
        link = self._getExternalLink( story )
        if not link:
            return        
        jira.updateIssue( story.summary, story.detail, link.external_id )

    def taskStatusChange(self, project, task):
        
        if not self._isConfigured(project):            
            return
        
        config, jira = self._getConfigJira(project) 
        
        link = self._getExternalLink( task )
        if not link:
            return
        story = task.story
        status = "Completed" if task.complete else "Not Complete"
        body = "[Task for ScrumDo Story %s-%d|%s%s#story_%s] changed to %s" % (project.prefix, story.local_id, settings.BASE_URL,
                                                                                                reverse('iteration', args=[story.project.slug, story.iteration.id]),
                                                                                                story.id,
                                                                                                status )
        jira.addComment(link.external_id, body)



    def storyStatusChange( self, project, story, **kwargs):
        
        if not self._isConfigured(project):            
            return
        
        config, jira = self._getConfigJira(project) 
        if not config[configuration.IMPORT_FIELD]:
            # We're not importing bugs as stories.
            return
        
        link = self._getExternalLink( story )
        if not link:
            return
        body = "[ScrumDo Story %s-%d|%s%s#story_%s] changed to %s" % (project.prefix, story.local_id, settings.BASE_URL,
                                                                                                reverse('iteration', args=[story.project.slug, story.iteration.id]),
                                                                                                story.id,
                                                                                                story.statusText() )
        jira.addComment(link.external_id, body)
            
    def storyImported(self, project, story):
        # No automatic issue creation.
        pass


    def _getExternalLink( self, story ):
        """ Searches for the ExternalStoryMapping that is associated with this extra and returns it.
            returns None if it's not found. """
        for link in story.external_links.all():
            if link.extra_slug == self.getSlug():
                return link
        return None

    def _getStoriesInProjectAssociatedWithExtra(self, project):
        rv = []
        for story in project.stories.all():
            if self._getExternalLink( story ) != None:
                rv.append( story )
        return rv

    def _getStory( self, external_id, queue_stories, project_stories ):
        """ Pass in an external id, list of stories in the queue, and a list of stories in the project, and will return the story if the it exists in either list. """
        story = self._getStoryFromQueue( external_id, queue_stories)
        if story != None:
            return story
        return self._getStoryFromProject( external_id, project_stories )

    def _getStoryFromProject(self, external_id, project_stories ):
        """ Returns the story from the list with the given external ID for this extra. """
        for project_story in project_stories:
            for link in project_story.external_links.all():
                if link.extra_slug == self.getSlug() and str(link.external_id)==str(external_id):
                    return project_story
        return None

    def _getStoryFromQueue(self, external_id, queue_stories ):
        """ Returns the story from the list of StoryQueue objects with the given external id. """
        for queue_story in queue_stories:
            if queue_story.extra_slug == self.getSlug() and queue_story.external_id==external_id:
                return queue_story
        return None            
        
    def _getTaskLink( self, task ):
        # We don't map tasks to jira issues in this plugin
        return None
    
    def _isConfigured(self, project):
        config = self.getConfiguration( project.slug )
        return (configuration.URL_FIELD in config) and (configuration.USERNAME_FIELD in config) and (configuration.PASSWORD_FIELD in config) and (configuration.IMPORT_FIELD in config)
    
    def _getConfigJira(self, project):
        config = self.getConfiguration( project.slug )
        url = config[configuration.URL_FIELD]
        username = config[configuration.USERNAME_FIELD]
        password = config[configuration.PASSWORD_FIELD]
        jira = Jira(url, username, password)
        return (config, jira)


Plugin = JiraExtra